# 第一章 温故而知新

- 程序为什么要被编译器编译了之后才可以运行？
- 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么？怎么做的？
- 最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的？怎么组织的？
- #include <stdlib.h>是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它是怎么实现的？
- 不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、ARM），以及不同的操作系统（Windows、Linux），最后编译出来的结果一样吗？为什么？
- Hello World程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执，到哪儿结束？main函数之前发生了什么？main函数结束后又发生了什么？
- 如果没有操作系统，Hello World可以运行吗？如果要在一台没有操作系统的机器上运行Hello World需要什么？应该怎么实现？
- printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？
- Hello World程序在运行时，它在内存中是什么样子的？

# 第二章 编译和链接

GCC编译过程分为4个步骤：

- 预处理（Prepressing）
- 编译（Compilation）
- 汇编（Assembly）
- 链接（Linking）

![](https://note.youdao.com/yws/public/resource/476396ff2aa7b2deab0b43fabd2fe624/xmlnote/FBC00B13447F4D7A8100F3C8A4F7076F/35818)

## 2.1 被隐藏的过程

### 2.1.1 预处理

预处理过程，主要是由 **预处理器cpp** 处理源代码中所有“#”开头的预编译指令。

```shell
gcc -E hello.c -o hello.i   // -E表示只进行预处理，hello.i是预编译后的文件
```

主要做以下几项工作

- 把所有头文件插入到对应位置，头文件中包含的其他头文件也会被插入进来
- 删除 "#define " 宏定义，并替换所有宏定义
- 删除所有的注释
- 处理所有条件预编译指令，如“#if 0" 、”#ifdef"、“#else"、"#endif"
- 添加文件名和行号，以便编译器产生调试用的行号信息，以及编译提示错误或警告时显示行号
- 保留所有 "#pragma" 编译器指令，因为编译器需要使用到

### 2.1.2 编译

编译就是把预处理后的文件，进行词法分析、语法分析、语义分析、优化，然后生成汇编代码，是整个过程中最核心的部分

```shell
gcc -S hello.c -o hello.s  // -S表示只进行预处理和编译
```

### 2.1.3 汇编

汇编就是根据汇编指令和机器指令的对照表，把汇编代码翻译成机器指令

```shell
gcc hello.s -o hello.o
```

### 2.1.4 链接

## 2.2 编译器做了什么

编译过程一般分为6步

- 扫描
- 语法分析
- 语义分析
- 源代码优化
- 代码生成
- 目标代码优化

## 2.3 链接器年龄比编译器长

## 2.4 模块拼装——静态链接

将各个模块独立编译出来，将它们拼装成最终的可执行文件，这就是链接

链接过程主要包括了地址和空间分配、符号决议、重定位等步骤

# 第三章 目标文件里有什么

源代码经过编译但未进行链接，生成的中间文件叫做**目标文件**，在linux中后缀名为.o

## 3.1 目标文件的格式

Linux下的可执行文件是**ELF格式**的，它跟Windows下的PE格式都是COFF格式的变种。

目标文件因为内容和结构跟可执行文件相似，所以一般跟可执行文件采用同一种格式存储。

可以使用**file**命令查看文件格式

```shell
machun@mtjsz-server:~/compile_link$ file hello.o
hello.o: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6602f3872fc0c49ff244b41ec56a6b76fd54af4a, not stripped

machun@mtjsz-server:~/compile_link$ file /bin/bash
/bin/bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6f072e70e3e49380ff4d43cdde8178c24cf73daa, stripped
```



不仅可执行文件按照ELF格式存储，动态库、静态库都按照可执行文件格式存储

| ELF文件类型                   | 说明                                                         | 实例                    |
| ----------------------------- | ------------------------------------------------------------ | ----------------------- |
| 可重定位文件（目标文件）      | 包含代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 | linux下编译生成的.o文件 |
| 可执行文件                    | 可直接执行的程序                                             | /bin下的各种可执行文件  |
| 共享目标文件                  | 包含代码和数据，可以在两种情况下使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件；一种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 | linux下的so库           |
| 核心转储文件（core dump file) | 当进程意外终止时，系统可以将该进程的地址空间的内容，和终止时的一些其他信息转储到核心转储文件 | linux下的core dump      |



## 3.2 目标文件是什么样的

目标文件中，除了编译后的机器指令和数据，还有符号表、调试信息、字符串等。这些信息根据不同的属性，按照“段“ 的形式存储



![](https://note.youdao.com/yws/public/resource/476396ff2aa7b2deab0b43fabd2fe624/xmlnote/C6BDBE94AAD24443A1A608D2B5E876DF/35840)



- **文件头**：描述了整个文件的属性，包括文件是否可执行、是静态链接还是动态链接、入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，还包括一个段表。段表是一个数组，描述文件中各个段在文件中的偏移位置、段的属性
- **.text**：保存编译后的机器代码
- **.data**：保存已初始化的全局变量和局部静态变量
- **.bss**：保存未初始化的全局变量和局部静态变量。因为未初始化的全局变量和局部静态变量默认都是0，所以bss段只是给它们预留位置，并没有内容，所以在文件中不占空间



为什么把指令和数据分开存放？

- 分开存放，可以针对不同的区域，设置不同的读写权限。对进程而言，数据区域是可读可写的，而为了防止指令区域被有意或无意的改写，所以指令区域是只读的。
- 如果系统中运行多个该进程，因为指令是一样的，所以内存中只需加载一份指令即可。而数据部分，每个进程都是不一样的，所以每个进程都需要单独的数据部分。使用这种方式，可以节省大量内存
- 指令和数据分开，可以提高程序的局部性，进而提高CPU的缓存命中率



## 3.3挖掘SimpleSection.o

```c
/*
 * SimpleSection.c
 *
*/
int printf(const char* format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i)
{
    printf("%d\n", i);
}

int main(void)
{
    static int static_var = 85;
    static int static_var2;

    int a = 1;
    int b;

    func1(static_var + static_var2 + a + b);

    return a;
}
```















