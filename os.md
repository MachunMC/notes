# 学习资源

- 清华大学 学堂在线：[操作系统 - 清华大学 - 学堂在线 (xuetangx.com)](https://www.xuetangx.com/course/THU08091000267/5883104?channel=learn_title)





# 第二讲

## 1. 操作系统的启动

操作系统存放在硬盘上。系统上电后，执行的第一条指令是存放在内存中的。内存分为RAM（掉电数据丢失）、ROM（掉电数据不丢失），系统初始化的代码保存在ROM中，上电后开始执行这部分代码

- 系统初始化的代码存放在内存中，那这部分代码是怎么放到内存中的？内存条生产的时候放进去的吗？
- 如果系统初始化的代码存放在磁盘中，上电后这部分代码怎么读到内存中？又由谁来读？



BIOS的功能

- 基本输入、输出
- 保存和设置系统信息（从磁盘/光盘启动等等信息）
- 上电自检，检查外设是否可以正常工作
- 将BootLoader从磁盘读到内存，然后把控制权交给BootLoader



BootLoader的功能：

- 将操作系统的代码和数据从硬盘加载到内存
- 跳转到操作系统的起始地址，然后开始加载操作系统



为啥BIOS不直接加载操作系统，为啥要用BootLoader来加载？

BIOS无法识别操作系统，而BootLoader可以识别操作系统，可以读取内核镜像



<img src="https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/B192FB72CB0A4CDCB4182339C2F934CF/27718" style="zoom: 50%;" />



启动顺序：

BIOS  --->  BootLoader  ---> OS



- 主引导记录：记录从哪个分区加载哪个操作系统

<img src="https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/07239D4863B74F99A43C6C99EEE9EF7A/27720" style="zoom:80%;" />



## 2. 中断、异常、系统调用

**为什么需要中断、异常、系统调用？**

- 在计算机系统中，内核是被信任的第三方
- 只有内核可以使用特权指令
- 为应用程序提供服务，方便其使用



**中断和异常希望解决的问题？**



**系统调用希望解决的问题？**

让应用程序既能方便的使用内核提供的服务，又不至于对系统的安全产生影响



<img src="https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/5E98FD0795EC408F8D4CA7560BD44286/27722" style="zoom:67%;" />



- 系统调用：应用程序主动向操作系统发出的服务请求

- 异常：非法指令或其他原因，导致的当前指令执行失败后的处理请求

- 中断：来自硬件设备的处理请求



**中断、异常、系统调用，三者的区别和联系？**

**区别**：

- 源头
  - 中断：外设
  - 异常：应用程序意想不到的行为
  - 系统调用：应用程序请求操作系统提供服务
- 处理时间
  - 中断：异步
  - 异常：同步
  - 系统调用：异步或同步
- 响应状态
  - 中断：持续，对应用程序是透明的
  - 异常：杀死或重新执行产生异常的应用程序
  - 系统调用：等待和持续



**中断处理机制：**

- 硬件处理
  - 在CPU初始化时，设置中断使能标志
    - 依据内部或外部事件，设置中断标志
    - 依据中断向量表，调用相应的中断服务例程
- 软件处理
  - 记录现场（编译器）
  - 中断服务处理（中断服务例程）
  - 清除中断标志（中断服务例程）
  - 恢复现场（编译器）



**中断嵌套**

- 硬件中断服务例程可被打断
  - 不同的硬件中断源，可能在硬件中断处理时出现
  - 硬件中断服务例程中，需要临时禁止中断请求
  - 中断请求会保持到CPU做出响应
- 异常服务例程可被打断
  - 异常服务例程执行时，可能出现硬件中断
- 异常服务例程可嵌套
  - 异常服务例程可能出现缺页



**系统调用**

- 由操作系统提供的接口
- 通常由高级语言调用（C或C++）
- 程序通常是通过高层次的接口进行访问，而不直接调用系统调用



**系统调用的实现**（系统调用是一个软中断）

- 每个系统调用对应一个系统编号
  - 系统调用接口，根据系统调用编号来维护表的索引
- 系统调用接口，调用内核态中的系统调用功能实现，并返回状态和结果
- 用户不需要知道系统调用的实现
  - 需要设置参数，获取返回结果
  - 系统接口的大部分细节，都隐藏在接口背后



**系统调用和函数调用的区别**

- 系统调用涉及到用户态和内核态的切换，用户态和内核态有不同的堆栈，内核态可以执行特权指令
- 函数调用都处于用户态，堆栈也都是用户态的



中断、异常和系统调用的开销，都大于函数调用，多余的开销在于：

- 引导机制（硬件）
- 建立内核堆栈
- 内核需要验证参数
- 内核态映射到用户态的地址空间
- 内核态独立地址空间



